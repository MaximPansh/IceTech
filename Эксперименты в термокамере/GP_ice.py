# -*- coding: utf-8 -*-
from math import pi

def onelayer_h (h, d, ro_b=0.919, ro_w=1):
    """
    Вычисляет приведённую толщину 1-слойного композитного ледяного покрова
    Запрашивает толщину проморозки h, диаметр шариков d, плотность шарика ro_b=0,919, плотность воды ro_w=1
    Возвращает приведённую толщину льда h_cond.
    """
    R=d/2 #Радиус шарика
    S=pow(3,0.5)*pow(R,2)   #Площадь элементарного треугольника разбивки поля льда
    V_b=(4/3)*pi*pow(R,3)    #Объём шарика
    V_upseg=V_b*(1-ro_b/ro_w)   #Объём шарового сегмента, торчащего над поверхностью воды
    #Расчёт высоты, на которую шарик торчит из воды:
    A=pow(((2*ro_b+2j*pow(ro_b*(ro_w-ro_b),0.5))/ro_w)-1,1/3)
    h_upseg=((2-1j*pow(3,0.5)*(A-pow(A,-1))-(A+pow(A,-1)))/2).real*R
    if d == 3:
        h = h - h_upseg
        
    def compare(h):
        #print(h+h_upseg)
        if (h+h_upseg)<d:#Если без переморозки
            #print('here')
            h_dowseg=d-h_upseg-h  #Расчёт высоты, на которую шарик торчит вниз под нижней поверхностью льда
            V_dowseg=pi*pow(h_dowseg,2)*(R-h_dowseg/3)  #Объём сегмента шарика, торчащий под поверхностью льда
            h_cond1=h+(V_upseg+V_dowseg)/(2*S)   #Приведённая толщина

        else:   #Если с переморозкой
            h_cond1=h+V_upseg/(2*S)
        return h_cond1
    
    try:
        h_cond = compare(h)
    except:
        h_cond = []       
        for hi in  h:
            h_cond.append(compare(hi))
                
    return h_cond
    
    
   
def cone_h (h, ro_c=0.919, ro_w=1,d=10,D=20, H=20):
    """
    Вычисляет приведённую толщину 1-слойного композитного ледяного покрова состоящего из конусов
    Запрашивает толщину проморозки h, диаметр конуса больший D и меньший d,высоту кноуса H плотность шарика ro_b=0,919, плотность воды ro_w=1
    Возвращает приведённую толщину льда h_cond.
    """
    ro_s=ro_c/ro_w
    d1=(((ro_s)*((D**3)-(d**3))+d**3))**(1/3) #диаметр ватерлинии
    C=(D-d)/H
    h1=(C**-1)*(D-d1)
    if h>=(H-h1): #если есть переморозка
        h_cond=h+(((3.14*h1)*((D**2)+D*d1+(d1**2)))/(6*(D**2)*(3**0.5)))
    else: #если нет переморозки
        h_cond=h+(3.14/((2*(3)**0.5)*D**2)*((C**2)/3*((H**3)-(h**3))+H*D*d-h*(d1**2)+h**2*C*d1))
    return h_cond           
#print (cone_h(10))           
#input()

 
def multylayer (h, d, N, ro_b=0.919, ro_w=1):
    """
    Вычисляет приведённую толщину многослойного композитного ледяного покрова
    Запрашивает толщину проморозки h, диаметр шариков d,колличество слоёв N, плотность шарика ro_b=0,919, плотность воды ro_w=1
    Возвращает приведённую толщину льда h_cond.
    """
    ro_s=ro_b/ro_w
    R=d/2
    A=(1+2*N*(ro_s-1)*(((1+(N**-1)*(ro_s-1)**-1)**0.5)+1))**(1/3)
    h1=((R/(2*A))*(A-1)*(((1j*(3**0.5))+1)*(A+1)-2*A)).real # высота надводного борта шарика
    
    print(h1)
    
    V1=N*(4/3)*pi*(R**3)*(1-ro_s) # V1 – объём частей верхнего слоя шариков, возвышающихся надо льдом
    V2=(pi/81)*((2*(6**0.5)*R*(1-N)+3*(h1-2*R+h))**2)*(2*(6**0.5)*R*(1-N)+3*(h1+R+h)) # V2– объём частей нижнего слоя шариков, выступающих под нижней поверхностью слоя льда
    V3=(pi/81)*((2*(6**0.5)*R*(2-N)+3*(h1-2*R+h))**2)*(2*(6**0.5)*R*(2-N)+3*(h1+R+h)) # V3– объём частей предпоследнего слоя шариков, выступающих под нижней поверхностью льда
    
    if N>=2:# При многослойном льде
        if (2*R*((2/3)**0.5)*(N-1))-h1 < h < (2*R*((2/3)**0.5)*(N-2)+2*R-h1):
            h_cond=h+((V1+V2+V3)/(2*(R**2)*(3**0.5)))
        elif (2*R*((2/3)**0.5)*(N-2)+2*R-h1) <= h < (2*R*((2/3)**0.5)*(N-1)+2*R-h1):
            V3=0
            h_cond=h+((V1+V2+V3)/(2*R**2*3**0.5))
        elif h>=(2*R*((2/3)**0.5)*(N-1)+2*R-h1):
            V2=0
            V3=0
            h_cond=h+((V1+V2+V3)/(2*R**2*3**0.5))
        else:
            return print ('гранулы проморожены не полностью')     
    else: # При однослойном льде
        if 0 < h < (2*R-h1):
            V3=0
            h_cond=h+((V1+V2+V3)/(2*R**2*3**0.5))
        else:
            V2=0
            V3=0
            h_cond=h+((V1+V2+V3)/(2*R**2*3**0.5))
    return h_cond
